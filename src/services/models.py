"""Pydantic models that define contracts between the UI and service layer."""

from __future__ import annotations

from typing import Literal, Optional, TYPE_CHECKING

from pydantic import BaseModel, Field, ConfigDict, field_validator

if TYPE_CHECKING:  # pragma: no cover - only for typing
    from src.core.magnitude import MagnitudeResult


class TraceMetadata(BaseModel):
    """Minimal metadata required to run waveform analytics."""

    station: str = Field(default="UNK", description="Station code for the trace")
    channel: str = Field(default="CH", description="Channel code for the trace")
    sampling_rate: float = Field(gt=0, description="Sampling rate in Hz")

    model_config = ConfigDict(extra="forbid")

    @field_validator("station", mode="before")
    @classmethod
    def _normalize_station(cls, value: str | None) -> str:
        return str(value).upper() if value else "UNK"

    @field_validator("channel", mode="before")
    @classmethod
    def _normalize_channel(cls, value: str | None) -> str:
        return str(value).upper() if value else "CH"


class PickPayload(BaseModel):
    """Representation of a seismic pick relative to trace start."""

    phase: Literal["P", "S"] = Field(description="Seismic phase tag")
    time_rel: float = Field(ge=0, description="Time since trace start (seconds)")
    station: str = Field(min_length=1, description="Station code")
    channel: str = Field(min_length=1, description="Channel code")
    method: str = Field(default="manual", description="Acquisition method (manual/auto)")

    model_config = ConfigDict(extra="forbid")

    @field_validator("phase", mode="before")
    @classmethod
    def _ensure_upper(cls, value: str) -> str:
        return str(value).upper()

    @field_validator("station", "channel", "method", mode="before")
    @classmethod
    def _strip(cls, value: str) -> str:
        return str(value).strip()


class PickSuggestion(BaseModel):
    """Output suggestion generated by the service layer."""

    time_rel: float = Field(ge=0, description="Suggested pick time relative to trace start")
    score: float = Field(ge=0, description="Score or confidence for the suggestion")
    phase: str = Field(default="P?", description="Suggested phase label")
    method: str = Field(default="sta_lta", description="Algorithm that produced the suggestion")


class MagnitudeEstimate(BaseModel):
    """Normalized container for local magnitude estimation results."""

    ml: Optional[float] = Field(default=None, description="Estimated local magnitude")
    amplitude_mm: Optional[float] = Field(default=None, description="Peak Wood-Anderson amplitude (mm)")
    delta_ps: Optional[float] = Field(default=None, description="Time difference between P and S picks")
    distance_km: Optional[float] = Field(default=None, description="Approximate hypocentral distance")
    notes: str = Field(default="", description="Context notes about the computation")
    method: str = Field(default="wood_anderson", description="Backend algorithm identifier")
    warnings: list[str] = Field(default_factory=list, description="Warnings issued during computation")

    model_config = ConfigDict(frozen=True, extra="ignore")

    @classmethod
    def from_core(cls, result: "MagnitudeResult") -> "MagnitudeEstimate":
        return cls(
            ml=result.ml,
            amplitude_mm=result.amplitude_mm,
            delta_ps=result.delta_ps,
            distance_km=result.distance_km,
            notes=result.notes,
            method=result.method,
            warnings=list(result.warnings or []),
        )
